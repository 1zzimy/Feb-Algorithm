## 이분 탐색(Binary Search) 알고리즘

이분 탐색은 정렬된 배열에서 특정 값을 빠르게 찾기 위한 알고리즘입니다. 주어진 배열을 반복적으로 절반씩 나누어가며 목표 값을 찾아냅니다. 이를 통해 탐색의 시간 복잡도를 `O(log n)`으로 줄일 수 있습니다.

### 이분 탐색의 주요 과정

1. 처음 범위는 0부터 끝까지이다. 이 때 중간 인덱스를 mid로 한다.
 
2. mid의 값와 찾는 원소를 비교한다.
- 1) 찾는 원소와 mid의 값이 같다면 탐색 종료한다.
- 2) mid의 값 < 찾는 원소 일 때 left는 mid + 1로 하여   2번을 다시 반복한다.
- 3) mid의 값 > 찾는 원소 일 때 right는 mid - 1 로 하여 2번을을 다시 반복한다.

3. 만약 right > left가 된다면 해당 배열에 찾는 원소가 없는 것이다.
  

### 이분 탐색의 시간 복잡도

- **시간 복잡도**: `O(log n)`
  - 각 반복마다 탐색 범위를 절반으로 줄여가므로 탐색 범위가 `n`에서 `log n`으로 줄어듭니다.
  
- **공간 복잡도**: `O(1)`
  - 배열을 탐색하는 과정에서 추가적인 공간을 사용하지 않으므로 공간 복잡도는 상수입니다.

## 정렬(Sorting) 알고리즘

정렬(Sorting)은 데이터를 특정한 순서대로 나열하는 작업입니다. 정렬된 데이터는 검색, 분석, 저장 등을 더욱 효율적으로 할 수 있게 해줍니다. 정렬 알고리즘은 다양한 방식으로 구현될 수 있으며, 각각의 방식은 시간 복잡도와 공간 복잡도가 다릅니다.

#### 1. 버블 정렬 (Bubble Sort)

버블 정렬은 인접한 두 요소를 비교하고, 자리가 바뀌어야 한다면 두 값을 교환하는 방식입니다. 이 과정을 반복하며 배열을 정렬합니다.

**과정**:
- 인접한 두 요소를 비교하여 더 큰 값이 오른쪽에 오도록 교환합니다.
- 전체 배열을 끝까지 반복하며, 최댓값을 오른쪽으로 이동시킵니다.

**시간 복잡도**: `O(n^2)`
- 최악의 경우 모든 요소를 비교해야 하기 때문에 시간이 많이 소요됩니다.

#### 2. 선택 정렬 (Selection Sort)

선택 정렬은 배열에서 가장 작은 값(혹은 가장 큰 값)을 찾아 맨 앞의 값과 교환하는 방식입니다.

**과정**:
- 배열에서 가장 작은 값을 찾아 첫 번째 위치와 교환합니다.
- 두 번째 위치부터 끝까지 같은 과정을 반복하여 정렬합니다.

**시간 복잡도**: `O(n^2)`
- 중간에 불필요한 교환이 발생하기 때문에 비교적 효율이 떨어집니다.

#### 3. 병합 정렬 (Merge Sort)

병합 정렬은 배열을 분할하고, 각 배열을 재귀적으로 정렬한 후 두 배열을 합쳐서 정렬하는 방법입니다.

**과정**:
- 배열을 반으로 나누고, 각 부분 배열을 재귀적으로 병합 정렬합니다.
- 두 정렬된 부분 배열을 하나로 합칩니다.

**시간 복잡도**: `O(n log n)`
- 배열을 반으로 나누고 합치는 과정에서 시간이 효율적으로 분배됩니다.

#### 4. 퀵 정렬 (Quick Sort)

퀵 정렬은 배열에서 하나의 요소(피벗)를 선택하고, 피벗을 기준으로 배열을 두 부분으로 나누어 정렬하는 분할 정복 방식입니다.

**과정**:
- 피벗을 선택하고, 피벗을 기준으로 왼쪽 부분에는 피벗보다 작은 값들을, 오른쪽 부분에는 피벗보다 큰 값들을 배치합니다.
- 각 부분에 대해 다시 퀵 정렬을 적용합니다.

**시간 복잡도**: `O(n log n)` (평균적으로)
- 피벗을 잘 선택하면 매우 빠르게 정렬할 수 있습니다. 하지만 최악의 경우 시간 복잡도가 `O(n^2)`가 될 수 있습니다.

### 정렬 알고리즘의 시간 복잡도 비교

| 알고리즘       | 시간 복잡도(최선) | 시간 복잡도(최악) | 공간 복잡도 |
| -------------- | ---------------- | ---------------- | ----------- |
| 버블 정렬      | O(n)             | O(n^2)           | O(1)        |
| 선택 정렬      | O(n^2)           | O(n^2)           | O(1)        |
| 삽입 정렬      | O(n)             | O(n^2)           | O(1)        |
| 병합 정렬      | O(n log n)       | O(n log n)       | O(n)        |
| 퀵 정렬       | O(n log n)       | O(n^2)           | O(log n)    |
| 힙 정렬        | O(n log n)       | O(n log n)       | O(1)        |
