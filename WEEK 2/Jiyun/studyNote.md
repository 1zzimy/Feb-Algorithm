# 정렬 (Sorting)

정렬 알고리즘은 다양한 방식으로 구현될 수 있다. 

## 선택 정렬 (Selection Sort)

- 정렬 방식
  1. 배열에서 최소값을 찾아 첫 번째 원소와 교환
  2. 두 번째 원소 이후의 배열에서 최소값을 찾아 두 번째 원소와 교환
  3. 이 과정을 배열 끝까지 반복

- 특징
  + 비교적적 단순한 알고리즘
  + 시간 복잡도가 $O(n^2)$으로 비효율적

![](https://velog.velcdn.com/images/ajm0718/post/c56c2a99-4c3f-4471-b157-9f100f779053/image.png)

## 버블 정렬 (Bubble Sort)

- 정렬 방식
  1. 첫 번째 원소와 두 번째 원소를 비교하며 정렬
  2. 두 번째 원소와 세 번째 원소를 비교하여 정렬
  3. 이를 배열의 끝까지 반복하여 가장 큰 값을 맨 뒤로 보냄 (한 패스)
  4. 이 과정을 반복하여 전체 정렬
  
- 특징
  + 한 번의 패스마다 가장 큰 값이 맨 뒤로 이동
  + 시간 복잡도가 $O(n^2)$으로 비효율적

![](https://blog.kakaocdn.net/dn/cktF30/btrJBFS6n6U/zipvEED7or08CAvWXskrHk/img.png)

## 삽입 정렬 (Insertion Sort)

- 정렬 방식
  1. 두 번째 원소부터 시작해, 그 앞의 정렬된 부분에서 적절한 위치를 찾아 삽입
  2. 모든 원소에서 위 과정을 반복
  
- 특징
  + 최악의 경우 $O(n^2)$, 최선의 경우(이미 정렬된 경우) $O(n)$
  + 데이터가 거의 정렬된 상태에서 매우 효율적

![](https://static.podo-dev.com/blogs/images/2019/07/10/origin/AUD5BF181224235510.PNG)

## 카운팅 정렬 (Counting Sort)

- 정렬 방식
  1. 입력 데이터의 최댓값을 찾고, 그 크기의 카운트 배열을 생성
  2. 각 숫자의 등장 횟수를 카운트 배열에 저장
  3. 누적합을 이용해 정렬된 위치를 결정한 뒤 출력 배열 생성
  
- 특징
  + 정수 범위가 제한된 경우에만 사용 가능
  + 시간 복잡도는 $O(n + k)$ ($k$는 숫자의 최대값)
  + 추가적인 공간이 필요해 공간 복잡도가 큼

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FM2d0N%2FbtqEuzQKkA3%2Fkc1r9KKWnW1x7RcelhfFK0%2Fimg.png)

## 병합 정렬 (Merge Sort)

- 정렬 방식
  1. 배열을 절반으로 분할
  2. 각 부분을 재귀적으로 정렬
  3. 정렬된 두 부분을 병합
  
- 특징
  + 시간 복잡도는 항상 $O(n log n)$
  + 안정 정렬(Stable Sort)로 원소의 상대적 순서가 유지됨
  + 재귀를 사용해 추가적인 공간을 필요로 함

![](https://static.podo-dev.com/blogs/images/2019/07/10/origin/TZ6DJE181224235510.PNG)

## 퀵 정렬 (Quick Sort)

- 정렬 방식
  1. 배열에서 Pivot(기준점) 선택
  2. Pivot을 기준으로 작은 값과 큰 값으로 나눔
  3. 각 부분을 재귀적으로 정렬
  
- 특징
  + 평균 시간 복잡도는 $O(n log n)$, 최악의 경우 $O(n^2)$ (Pivot을 잘못 선택했을 때)
  + 추가적인 공간이 거의 필요하지 않은 제자리 정렬(In-place Sort)이지만, 불안정 정렬(Unstable Sort)

![](https://blog.kakaocdn.net/dn/3lb5Q/btrshyJIiQF/kNoD2RLRPWYXebk59C57gk/img.png)

## 힙 정렬 (Heap Sort)

- 정렬 방식
  1. 주어진 배열을 힙으로 전환
  2. 힙에서 루트를 꺼내 정렬
  3. 위 과정을 반복
  
- 특징
  + 시간 복잡도는 $O(n log n)$
  + 제자리 정렬, 비안정 정렬

<br/>
<br/>

# 정렬 알고리즘 비교
| 정렬 | 평균 시간 복잡도 | 최악 시간 복잡도 | 공간 복잡도 | 안정 정렬 | 제자리 정렬 |
|--------------|----------------|----------------|------------|--------------|--------------|
| 선택 정렬 | $O(n^2)$ | $O(n^2)$ | $O(1)$ | X | O |
| 버블 정렬 | $O(n^2)$ | $O(n^2)$ | $O(1)$ | O | O |
| 삽입 정렬 | $O(n^2)$ | $O(n^2)$ | $O(1)$ | O | O |
| 카운팅 정렬 | $O(n + k)$ | $O(n + k)$ | $O(k)$ | O | X |
| 병합 정렬 | $O(n \log n)$ | $O(n \log n)$ | $O(n)$ | O | X |
| 퀵 정렬 | $O(n \log n)$ | $O(n^2)$ | $O(\log n)$ | X | O |
| 힙 정렬 | $O(n \log n)$ | $O(n \log n)$ | $O(1)$ | X | O |


## 안정 정렬 (Stable Sort)
- 같은 값을 가진 데이터들의 상대적인 순서가 정렬 후에도 유지되는 정렬 방식

- 필요성
  + 2개의 기준으로 정렬할 때 : 예를 들어, 학생의 성적을 정렬하되 점수가 같은 경우 이름의 사전순을 유지하고 싶은 경우
  + 기존의 정렬된 데이터 유지 : 먼저 성별로 정렬한 후, 같은 성별 내에서 나이를 정렬하는 경우

## 제자리 정렬 (In-Place Sort)
- 추가적인 메모리 공간을 거의 사용하지 않는 정렬 방식
  + 입력 배열 내에서 직접 원소를 교환하며 정렬

- 필요성
  + 메모리 사용이 적음 : 제한된 공간에서 정렬해야 하는 경우
  + 캐시 친화적 : 연속적인 메모리 접근이 가능해 CPU 캐시 활용이 효율적

<br/>

# Sorting in Java

### `Arrays.sort()` - 기본 타입(`int[]`, `double[]`)
- Dual-Pivot Quick Sort
  + 두 개의 Pivot을 사용해 퀵 정렬을 개선한 방식
  + 구간을 3개로 분할하여 작은 값은 왼쪽, 중간 값은 중앙, 큰 값은 오른쪽에 배치
  + 각 구간을 재귀적으로 정렬

- 성능
  + 기존의 퀵 정렬보다 성능이 좋으며, 특히 큰 배열에 효과적
  + 평균 시간복잡도 $O(n log n)$
  + 최악의 시간복잡도 $O(n^2)$ (거의 일어나지 않음)
  + 제자리 정렬
  + 불안정 정렬

### `Arrays.sort()` - 참조 타입(`Integer[]`, `String[]`)

- Tim Sort
  + 병합 정렬과 삽입 정렬을 조합한 알고리즘
  + 작은 배열(64개 이하)은 삽입 정렬 사용
  + 큰 배열은 병합 정렬 사용
  + 기존의 병합 정렬을 최적화해 추가적인 정렬이 필요하지 않은 부분을 자동으로 감지하고 생략

- 성능
  + 정렬된 데이터가 많을수록 빠르게 동작
  + 평균 및 최악의 시간복잡도 $O(n log n)$
  + 안정 정렬

### `Collections.sort()`

- 내부적으로 `Arrays.sort(Object[])`를 호출하기 때문에, Tim Sort 사용

<br/>
<br/>
<br/>
<br/>

# 이분 탐색 (Binary Search)

정렬된 알고리즘에서 특정 값을 빠르게 찾는 탐색 알고리즘

일반적인 선형 탐색 알고리즘은 $O(n)$의 시간복잡도를 가지지만, 이분 탐색은 $O(log n)$의 성능을 보인다.

- 동작 방식
  + 정렬되어 있는 배열에서 중간값 선택
    + 찾는 값이 중간보다 크면 > 오른쪽 탐색
    + 찾는 값이 중간보다 작으면 > 왼쪽 탐색
    + 찾는 값이 중간이랑 같으면 > 탐색 종료
  + 위 과정을 값이 발견되거나 탐색 범위가 없을 때까지 반복

- 적용 조건
  + 데이터가 정렬되어 있어야 함
  + 빠른 검색이 필요할 때 사용
  + 삽입과 삭제가 빈번한 경우엔 적합하지 않음

- Lower Bound / Upper Bound
  + Lower Bound : 특정 값 이상의 첫 번째 위치 찾기
  + Upper Bound : 특정 값 초과의 첫 번째 위치 찾기

- 응용
  + 이진 검색 트리(Binary Search Tree, BST)
  + 매개변수 검색(Parametric Search)
  