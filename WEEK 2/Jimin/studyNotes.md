# **[Week 2] Sort, Binary Search**



### 1. 정렬 (Sorting)
- 데이터를 순서대로 나열하는 과정(오름차순, 내림차순 등)
- 주요 정렬 알고리즘
    - **선택 정렬 (Selection Sort)**
        - 개념 : 매번 가장 작은(또는 큰) 값을 선택하여 앞으로 보내는 방식
        - 방법 : 배열에서 가장 작은 값을 찾아 첫 번째 위치와 교환, 그 다음 작은 값을 찾아 두 번째 위치와 교환
    - **버블 정렬 (Bubble Sort)**
        - 개념 : 인접한 두 요소를 비교하여 큰 값을 오른쪽으로 “버블”처럼 밀어내는 방식
        - 방법 : 배열을 반복하면서 서로 인접한 두 값을 비교 후 교환, 한 번 순회할 때마다 가장 큰 값이 맨 뒤로 정렬됨
    - **삽입 정렬 (Insertion Sort)**
        - 개념 : 현재 요소를 앞쪽의 정렬된 부분에 삽입하는 방식
        - 방식 : 두 번째 요소부터 시작해 앞의 요소들과 비교 후 적절한 위치에 삽입
    - **카운팅 정렬 (Counting Sort)**
        - 개념 : 각 요소의 개수를 세서 정렬하는 방식 (숫자의 빈도를 기반으로 정렬)
        - 제약 조건 : 정수 데이터(특히 범위가 작을 때)에 적합
    - **병합 정렬 (Merge Sort)**
        - 개념 : 데이터를 절반으로 나누고, 나눈 부분을 정렬한 뒤 병합하는 방식 (분할 정복)
        - 방법 : 배열을 재귀적으로 나누고, 작은 단위부터 병합하면서 정렬
    - **퀵 정렬 (Quick Sort)**
        - 개념 : 피벗(Pivot)을 기준으로 작은 값과 큰 값을 분할하고, 재귀적으로 정렬하는 방식
        - 방법 : 피벗 선택 → 피벗보다 작은 값은 왼쪽, 큰 값은 오른쪽으로 분할 → 각 부분 재귀 호출
    - **힙 정렬 (Heap Sort)**
        - 개념 : 힙 자료구조를 활용하여 최대값 또는 최소값을 쉽게 추출하는 방식
        - 방법 : 최대 힙 구성 → 루트 노드(최대값)와 마지막 값 교환 후 정렬
    
    | 정렬 알고리즘 | 시간 복잡도(평균) | 시간 복잡도(최악) | 공간 복잡도 | 안정성 | 특징 |
    | --- | --- | --- | --- | --- | --- |
    | 선택 정렬 | O(n²) | O(n²) | O(1) | X (불안정) | 간단하지만 비효율적 |
    | 버블 정렬 | O(n²) | O(n²) | O(1) | O (안정적) | 인접 요소 비교 (단순) |
    | 삽입 정렬 | O(n²) | O(n²) | O(1) | O (안정적) | 거의 정렬된 경우 빠름 |
    | 카운팅 정렬 | O(n + k) | O(n + k) | O(k) | O (안정적) | 정수 데이터에 최적 |
    | 병합 정렬 | O(n log n) | O(n log n) | O(n) | O (안정적) | 분할 정복 기반 |
    | 퀵 정렬 | O(n log n) | O(n²) | O(log n) | X (불안정) | 빠르지만 피벗 선택 중요 |
    | 힙 정렬 | O(n log n) | O(n log n) | O(1) | X (불안정) | 힙 자료구조 활용 |

### 2. 이분 탐색(Binary Search)

- 정렬된 배열에서만 사용 가능
- 탐색 범위를 절반씩 줄이며 빠르게 검색 → $O(log n)$ (데이터의 크기가 커질수록 탐색 속도 매우 빠름)